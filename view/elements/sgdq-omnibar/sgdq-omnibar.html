<link rel="import" href="../../components/polymer/polymer.html"/>

<dom-module id="sgdq-omnibar">
    <style>
        :host {
            display: flex;
            position: absolute;
            width: 1280px;
            bottom: 0;
            left: 0;
            color: white;
            font-family: "tablet-gothic";
            z-index: 10;
            align-items: flex-end;
        }

        #main {
            display: inline-flex;
            height: 53px;
            background: url("main_bg.png") repeat-x;
            border-top: 2px solid #95b1c3;
            flex-grow: 1;
            align-items: flex-end;
        }

        #head {
            display: inline-flex;
            align-items: flex-end;
            height: 100%;
            flex-shrink: 0;
        }

        #logoContainer {
            width: 118px;
            height: 100%;
            margin-right: -5px;
            background: url("logo_bg.png") no-repeat;
            z-index: 1;
        }

        #logo {
            margin-left: 6px;
            width: 92px;
            height: 100%;
            background: url("logo_gdq.png") no-repeat center;
        }

        #labelContainer {
            display: flex;
            width: 147px;
            height: 100%;
            padding-left: 5px;
            border-right: 2px solid white;
            text-align: center;
            background: url("label_bg.png") no-repeat right;
            background-color: #103A4E;
            align-items: center;
        }

        #label {
            width: 100%;
            font-weight: 400;
            line-height: 22px;
            margin-top: -3px;
        }

        #body {
            padding-left: 10px;
            padding-right: 12px;
            white-space: nowrap;
        }

        #topLine {
            font-family: "tablet-gothic-narrow";
            font-weight: 700;
            font-size: 18px;
            font-style: italic;
            text-transform: uppercase;
            line-height: 0;
            transform-origin: left;
        }

        #bottomLine {
            font-weight: 600;
            font-size: 26px;
            transform-origin: left;
        }

        #totalContainer {
            flex-shrink: 0;
        }

        #total {
            display: flex;
            height: 61px;
            margin-left: -2px;
            padding-left: 11px;
            padding-right: 11px;
            text-align: center;
            background: url("total_bg.png") no-repeat left;
            align-items: center;
            text-shadow: 1px 3px 3px rgba(0, 0, 0, 0.35);
            font-family: "tablet-gothic-narrow";
            font-weight: 700;
            font-size: 45px;
        }
    </style>

    <template>
        <div id="main">
            <div id="head">
                <div id="logoContainer">
                    <div id="logo"></div>
                </div>
                <div id="labelContainer">
                    <div id="label">UP NEXT</div>
                </div>
            </div>
            <div id="body">
                <div id="topLine">{{topText}}</div>
                <div id="bottomLine">{{bottomText}}</div>
            </div>
        </div>
        <div id="totalContainer">
            <div id="total"></div>
        </div>
    </template>
</dom-module>

<script>
    // TODO: up next, prizes, arbitrary

    Polymer({
        is: 'sgdq-omnibar',

        properties: {
            tl: {
                type: Object,
                value: new TimelineLite({autoRemoveChildren: true}),
                readOnly: true
            },
            padTime: {
                type: Number,
                value: 2,
                readOnly: true
            },
            displayDuration: {
                type: Number,
                value: 2,
                readOnly: true
            },
            lastShownGrandPrizeIdx: {
                type: Number,
                value: -1
            },
            initialized: {
                type: Boolean,
                value: false,
                readOnly: true
            },
            topText: {
                type: String,
                observer: 'fitBodyText'
            },
            bottomText: {
                type: String,
                observer: 'fitBodyText'
            },
            total: {
                type: String,
                value: 'Retrievingâ€¦',
                observer: 'totalChanged'
            }
        },

        totalChanged: function(newVal) {
            var self = this;
            TweenLite.to(this.$.total, 0.5, {
                text: newVal,
                ease: Linear.easeNone,
                onUpdate: function() {
                    self.fitBodyText();
                }
            });
        },

        fitBodyText: function() {
            var bodyWidth = this._getElementContentWidth(this.$.body);

            var bottomLineWidth = this.$.bottomLine.scrollWidth;
            if (bottomLineWidth > bodyWidth) {
                TweenLite.set(this.$.bottomLine, {scaleX: bodyWidth / bottomLineWidth});
            } else {
                TweenLite.set(this.$.bottomLine, {scaleX: 1});
            }

            var topLineWidth = this.$.topLine.scrollWidth;
            if (topLineWidth > bodyWidth) {
                TweenLite.set(this.$.topLine, {scaleX: bodyWidth / topLineWidth});
            } else {
                TweenLite.set(this.$.topLine, {scaleX: 1});
            }
        },

        /*
         * Lifecycle
         */
        ready: function () {
            // TODO: delete when done testing
            window.omnibar = this;

            var self = this;

            // Prep all elements for animation
            TweenLite.set(this.$.labelContainer, {x: '-100%'});

            // Set up Replicants
            nodecg.Replicant('currentBids')
                    .on('change', function (oldVal, newVal) {
                        window.currentBids = newVal;

                        // Bids are the first thing we show, so we use this to start our loop
                        if (!self.initialized) {
                            self._setInitialized(true);
                            self.showBids();
                        }
                    });

            nodecg.Replicant('currentPrizes')
                    .on('change', function (oldVal, newVal) {
                        window.currentGrandPrizes = newVal.filter(function (prize) {
                            return prize.grand;
                        });
                        window.currentNormalPrizes = newVal.filter(function (prize) {
                            return !prize.grand;
                        });
                        window.currentNormalPrizes = window.currentNormalPrizes.slice(0, 5);
                    });

            nodecg.Replicant('schedule')
                    .on('change', function (oldVal, newVal) {
                        window.schedule = newVal;
                        if (window.currentRun) {
                            var len = newVal.length;
                            for (var i = 0; i < len; i++) {
                                if (window.currentRun.name === newVal[i].name) {
                                    var newIndexOfCurrentRun = newVal[i].index;
                                }
                            }

                            window.nextRun = newVal[newIndexOfCurrentRun + 1];
                        } else {
                            // default "nextRun" to second run
                            window.nextRun = newVal[1];
                        }
                    });

            nodecg.Replicant('currentRun')
                    .on('change', function (oldVal, newVal) {
                        window.currentRun = newVal;

                        // If this is the last run, set next run to null
                        if (newVal.index === window.schedule.length - 1) {
                            window.nextRun = null;
                        } else {
                            window.nextRun = window.schedule[newVal.index + 1];
                        }
                    });

            nodecg.Replicant('total')
                    .on('change', function (oldVal, newVal) {
                        self.total = newVal;
                    });
        },

        /*
         * Methods
         */
        showBids: function (immediate) {
            var self = this;
            if (immediate) this.tl.clear();
            this.tl.call(this._showLabel, ['DONATION BIDS', '25px'], this);

            // Figure out what bids to display in this batch
            var bidsToDisplay = window.currentBids.slice(0, 3);
            var lastBidSpeedrun = bidsToDisplay[bidsToDisplay.length - 1].speedrun;
            var numBids = window.currentBids.length;
            for (var i = 2; i < numBids; i++) {
                if (window.currentBids[i].speedrun !== lastBidSpeedrun) break;
                bidsToDisplay.push(window.currentBids[i]);
            }

            // Loop over each bid and queue it up on the timeline
            bidsToDisplay.forEach(function (bid) {
                self.tl.to(self.$.body, 0.25, {
                    opacity: 0,
                    ease: Linear.easeNone,
                    onComplete: function () {
                        self.topText = 'BID FOR ' + bid.speedrun;
                        self.bottomText = bid.name + ' - ' + bid.total;
                    }
                });

                self.tl.to(self.$.body, 0.25, {
                    opacity: 1,
                    ease: Linear.easeNone
                });

                // Give the bid some time to show
                self.tl.to({}, self.displayDuration, {});
            });

            this.tl.call(this.showPrizes, null, this);
        },

        showPrizes: function (immediate) {
            var self = this;
            if (immediate) this.tl.clear();
            this.tl.call(this._showLabel, ['RAFFLE PRIZES', '25px'], this);

            // Figure out what grand prize to show in this batch.
            var lastShownGrandPrizeIdx = window.currentGrandPrizes.indexOf(self.lastShownGrandPrize);
            var nextGrandPrizeIdx = lastShownGrandPrizeIdx >= window.currentGrandPrizes.length - 1
                    ? 0
                    : lastShownGrandPrizeIdx + 1;
            var nextGrandPrize = window.currentGrandPrizes[nextGrandPrizeIdx];

            // Make a new array with our lone grand prize + all normal prizes
            var prizesToDisplay = window.currentNormalPrizes.slice(0);
            if (nextGrandPrize) prizesToDisplay.unshift(nextGrandPrize);

            // Loop over each prize and queue it up on the timeline
            prizesToDisplay.forEach(function (prize) {
                self.tl.to(self.$.body, 0.25, {
                    opacity: 0,
                    ease: Linear.easeNone,
                    onComplete: function () {
                        self.topText = 'PROVIDED BY ' + prize.provided;
                        if (prize.grand) {
                            self.bottomText = 'Grand Prize: ' + prize.name + ' (Minimum Bid: '
                                    + prize.minimumbid + ')';
                        } else {
                            self.bottomText = prize.name + ' (Minimum Bid: ' + prize.minimumbid + ')';
                        }
                    }
                });

                self.tl.to(self.$.body, 0.25, {
                    opacity: 1,
                    ease: Linear.easeNone
                });

                // Give the prize some time to show
                self.tl.to({}, self.displayDuration, {});
            });

            this.tl.call(this.showNext, null, this);
        },

        showNext: function (immediate) {
            if (window.nextRun) {
                var self = this;
                if (immediate) this.tl.clear();
                this.tl.call(this._showLabel, ['UP NEXT', '31px'], this);

                this.tl.to(this.$.body, 0.25, {
                    opacity: 0,
                    ease: Linear.easeNone,
                    onComplete: function () {
                        /* Depending on how we enter the very end of the schedule, we might end up in this func
                         * after window.nextRun has been set to null. In that case, we immediately clear the
                         * timeline and bail out to showing bids again.
                         */
                        if (window.nextRun) {
                            self.topText = window.nextRun.runners.join(', ');
                            self.bottomText = window.nextRun.game + ' - ' + window.nextRun.category;
                        } else {
                            self.tl.clear();
                            self.tl.call(self.showBids, null, self);
                        }
                    }
                });

                this.tl.to(this.$.body, 0.25, {
                    opacity: 1,
                    ease: Linear.easeNone
                });

                // Give it some time to show
                this.tl.to({}, this.displayDuration, {});

                this.tl.call(this.showBids, null, this);
            }
        },

        _showLabel: function (text, size) {
            var self = this;
            var tmpTL = new TimelineLite();
            if (this.labelShowing) {
                tmpTL.to(this.$.label, 0.25, {
                    opacity: 0,
                    ease: Linear.easeNone,
                    onComplete: function () {
                        self.$.label.innerHTML = text;
                        self.$.label.style.fontSize = size;
                    }
                });
                tmpTL.to(this.$.label, 0.25, {
                    opacity: 1,
                    ease: Linear.easeNone
                });
            } else {
                tmpTL.to(this.$.labelContainer, 0.5, {
                    onStart: function () {
                        self.labelShowing = true;
                        self.$.label.innerHTML = text;
                        self.$.label.style.fontSize = size;
                    },
                    x: '0%',
                    ease: Power3.easeOut
                });
            }
            return tmpTL;
        },

        _hideLabel: function () {
            var self = this;
            var tmpTL = new TimelineLite();
            this.tl.to(this.$.labelContainer, 0.5, {
                onStart: function () {
                    self.labelShowing = false;
                },
                x: '-100%',
                ease: Power3.easeIn
            });
            return tmpTL;
        },

        _padTimeline: function () {
            this.tl.to({}, this.padTime, {});
        },

        _getElementContentWidth: function (element) {
            var styles = window.getComputedStyle(element);
            var padding = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
            return element.clientWidth - padding;
        }
    });
</script>
