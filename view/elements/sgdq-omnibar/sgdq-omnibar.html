<link rel="import" href="../../components/polymer/polymer.html"/>
<link rel="import" href="../sgdq-qplate/sgdq-qplate.html"/>

<dom-module id="sgdq-omnibar">
    <style>
        :host {
            display: flex;
            position: absolute;
            width: 1280px;
            bottom: 0;
            left: 0;
            color: white;
            font-family: "tablet-gothic";
            z-index: 10;
            align-items: flex-end;
        }

        #main {
            display: inline-flex;
            height: 53px;
            background: url("main_bg.png") repeat-x;
            border-top: 2px solid #95b1c3;
            flex-grow: 1;
            align-items: flex-end;
        }

        #head {
            display: inline-flex;
            align-items: flex-end;
            height: 100%;
            flex-shrink: 0;
        }

        #logoContainer {
            width: 118px;
            height: 100%;
            margin-right: -5px;
            background: url("logo_bg.png") no-repeat;
            z-index: 1;
        }

        #logo {
            margin-left: 6px;
            width: 92px;
            height: 100%;
            background: url("logo_gdq.png") no-repeat center;
        }

        #labelContainer {
            display: flex;
            width: 147px;
            height: 100%;
            padding-left: 5px;
            border-right: 2px solid white;
            text-align: center;
            background: url("label_bg.png") no-repeat right;
            background-color: #103A4E;
            align-items: center;
        }

        #label {
            width: 100%;
            font-weight: 400;
            line-height: 22px;
            margin-top: -3px;
        }

        #body {
            display: flex;
            height: 100%;
            padding-left: 10px;
            padding-right: 12px;
            white-space: nowrap;
            flex-grow: 1;
            align-items: center;
            justify-content: center;
            perspective: 2000px;
        }

        #twoLines {
            display: block;
            width: 100%;
            height: 100%;
        }

        #topLine {
            font-family: "tablet-gothic-narrow";
            font-weight: 700;
            font-size: 18px;
            font-style: italic;
            text-transform: uppercase;
            transform-origin: left;
            margin-bottom: -13px; /* easiest way to position both this and #bottomLine properly */
        }

        #bottomLine {
            font-weight: 600;
            font-size: 26px;
            transform-origin: left;
        }

        #fullLine {
            font-size: 28px;
            font-family: "tablet-gothic";
            font-weight: 400;
        }

        #fullLine .flexCenter {
            display: flex;
            align-items: center;
        }

        /* Hilarious hack to get the text to appear more vertically centered */
        #fullLine span {
            transform: translateY(-2px);
        }

        #fullLine b {
            font-weight: 700;
        }

        #msf {
            background: url("logo_msf.png") no-repeat;
            width: 147px;
            height: 47px;
            margin-left: 18px;
        }

        #totalContainer {
            flex-shrink: 0;
        }

        #total {
            height: 61px;
            line-height: 57px;
            margin-left: -2px;
            padding-left: 11px;
            padding-right: 11px;
            text-align: center;
            background: url("total_bg.png") no-repeat left;
            align-items: center;
            text-shadow: 1px 3px 3px rgba(0, 0, 0, 0.35);
            font-family: "tablet-gothic-narrow";
            font-weight: 700;
            font-size: 45px;
        }

        #totalDollarSign {
            font-size: 30px;
            margin-right: -7px;
        }
    </style>

    <template>
        <div id="main">
            <div id="head">
                <div id="logoContainer">
                    <div id="logo"></div>
                </div>
                <div id="labelContainer">
                    <div id="label">UP NEXT</div>
                </div>
            </div>
            <div id="body">
                <div id="twoLines">
                    <sgdq-qplate id="topLine" origin-dist="5"></sgdq-qplate>
                    <sgdq-qplate id="bottomLine" direction="up" origin-dist="7"></sgdq-qplate>
                </div>
                <sgdq-qplate id="fullLine" center origin-dist="12"></sgdq-qplate>
            </div>
        </div>
        <div id="totalContainer">
            <div id="total">
                <span id="totalDollarSign">$</span>
                <span id="totalCash"></span>
            </div>
        </div>
    </template>
</dom-module>

<script>
    Polymer({
        is: 'sgdq-omnibar',

        properties: {
            tl: {
                type: Object,
                value: new TimelineLite({autoRemoveChildren: true}),
                readOnly: true
            },
            padTime: {
                type: Number,
                value: 2,
                readOnly: true
            },
            displayDuration: {
                type: Number,
                value: 3,
                readOnly: true
            },
            lastShownGrandPrizeIdx: {
                type: Number,
                value: -1
            },
            topText: {
                type: String,
                observer: 'topTextChanged'
            },
            bottomText: {
                type: String,
                observer: 'bottomTextChanged'
            },
            total: {
                type: String,
                value: '$0',
                observer: 'totalChanged'
            }
        },

        totalChanged: function(newVal) {
            var self = this;
            TweenLite.to(this.$.totalCash, 0.5, {
                text: newVal.replace('$', ''),
                ease: Linear.easeNone,
                onUpdate: function() {
                    self.$.topLine.fit();
                    self.$.bottomLine.fit();
                }
            });
        },

        topTextChanged: function(newVal) {
            this.$.topLine.fillHopperText(newVal);
        },

        bottomTextChanged: function(newVal) {
            this.$.bottomLine.fillHopperText(newVal);
        },

        /*
         * Lifecycle
         */
        ready: function () {
            // TODO: delete when done testing
            window.omnibar = this;

            var self = this;

            // Prep all elements for animation
            TweenLite.set(this.$.labelContainer, {x: '-100%'});

            // Set up Replicants
            nodecg.Replicant('currentBids')
                    .on('change', function (oldVal, newVal) {
                        window.currentBids = newVal;
                    });

            nodecg.Replicant('currentPrizes')
                    .on('change', function (oldVal, newVal) {
                        window.currentGrandPrizes = newVal.filter(function (prize) {
                            return prize.grand;
                        });
                        window.currentNormalPrizes = newVal.filter(function (prize) {
                            return !prize.grand;
                        });
                        window.currentNormalPrizes = window.currentNormalPrizes.slice(0, 5);
                    });

            nodecg.Replicant('schedule')
                    .on('declared', function() {
                        // Don't declare the "currentRun" replicant until the schedule replicant is declared
                        nodecg.Replicant('currentRun')
                                .on('change', function (oldVal, newVal) {
                                    window.currentRun = newVal;

                                    // If this is the last run, set next run to null
                                    if (newVal.index === window.schedule.length - 1) {
                                        window.nextRun = null;
                                    } else {
                                        window.nextRun = window.schedule[newVal.index + 1];
                                    }
                                });
                    })
                    .on('change', function (oldVal, newVal) {
                        window.schedule = newVal;
                        if (window.currentRun) {
                            var len = newVal.length;
                            for (var i = 0; i < len; i++) {
                                if (window.currentRun.name === newVal[i].name) {
                                    var newIndexOfCurrentRun = newVal[i].index;
                                }
                            }

                            window.nextRun = newVal[newIndexOfCurrentRun + 1];
                        } else {
                            // default "nextRun" to second run
                            window.nextRun = newVal[1];
                        }
                    });

            nodecg.Replicant('total')
                    .on('change', function (oldVal, newVal) {
                        self.total = newVal;
                    });

            nodecg.listenFor('barDemand', function(data) {
                switch (data.type) {
                    case 'bid':
                        self.showBid(data, true);
                        break;
                    case 'prize':
                        self.showPrize(data, true);
                        break;
                }
            });

            nodecg.listenFor('barCurrentBids', function() {
                self.showBids(true);
            });

            nodecg.listenFor('barCurrentPrizes', function() {
                self.showPrizes(true);
            });

            nodecg.listenFor('barUpNext', function() {
                self.showNext(true);
            });

            nodecg.listenFor('barCTA', function() {
                self.showCTA(true);
            });

            // Bids are the first thing we show, so we use this to start our loop
            self.showCTA();
        },

        /*
         * Methods
         */
        showBids: function (immediate) {
            var self = this;
            if (immediate) this.tl.clear();

            if (window.currentBids.length) {
                this.tl.call(this._showLabel, ['DONATION BIDS', '25px'], this);

                // Figure out what bids to display in this batch
                var bidsToDisplay = window.currentBids.slice(0, 3);
                var lastBidSpeedrun = bidsToDisplay[bidsToDisplay.length - 1].speedrun;
                var numBids = window.currentBids.length;
                for (var i = 2; i < numBids; i++) {
                    if (window.currentBids[i].speedrun !== lastBidSpeedrun) break;
                    bidsToDisplay.push(window.currentBids[i]);
                }

                // Loop over each bid and queue it up on the timeline
                bidsToDisplay.forEach(function(bid) {
                    self.showBid(bid);
                });
            }

            this.tl.call(this.showPrizes, null, this, '+=0.01');
        },

        showBid: function (bid, immediate) {
            var self = this;
            if (immediate) {
                this.tl.clear();

                // Silly, should do this in a more reliable fashion.
                //if (this.$.fullText)

                this.tl.call(this._showLabel, ['DONATION BIDS', '25px'], this);
            }

            // GSAP is dumb with `call` sometimes. Putting this in a near-zero duration tween seems to be more reliable.
            this.tl.to({}, 0.01, {
                onComplete: function() {
                    self.$.twoLines.style.display = 'block';
                    self.topText = 'BID FOR ' + bid.speedrun;
                }
            });

            this.tl.call(function() {
                self.bottomText = bid.name + ' - ' + bid.total;
            }, null, null, '+=0.08');

            // Give the bid some time to show
            this.tl.to({}, this.displayDuration, {});

            // If we're just showing this one bid on-demand, show "Prizes" next.
            if (immediate) this.tl.call(this.showPrizes, null, this, '+=0.01');
        },

        showPrizes: function (immediate) {
            var self = this;
            if (immediate) this.tl.clear();

            if (window.currentGrandPrizes.length || window.currentNormalPrizes.length) {
                this.tl.call(this._showLabel, ['RAFFLE PRIZES', '25px'], this);

                var prizesToDisplay = window.currentNormalPrizes.slice(0);
                if (window.currentGrandPrizes.length) {
                    // Figure out what grand prize to show in this batch.
                    var lastShownGrandPrizeIdx = window.currentGrandPrizes.indexOf(this.lastShownGrandPrize);
                    var nextGrandPrizeIdx = lastShownGrandPrizeIdx >= window.currentGrandPrizes.length - 1
                            ? 0
                            : lastShownGrandPrizeIdx + 1;
                    var nextGrandPrize = window.currentGrandPrizes[nextGrandPrizeIdx];
                    if (nextGrandPrize) prizesToDisplay.unshift(nextGrandPrize);
                }

                // Loop over each prize and queue it up on the timeline
                prizesToDisplay.forEach(function(prize) {
                    self.showPrize(prize);
                });
            }

            this.tl.call(this.showNext, null, this, '+=0.01');
        },

        showPrize: function (prize, immediate) {
            var self = this;
            if (immediate) {
                this.tl.clear();
                this.tl.call(this._showLabel, ['RAFFLE PRIZES', '25px'], this);
            }

            // GSAP is dumb with `call` sometimes. Putting this in a near-zero duration tween seems to be more reliable.
            this.tl.to({}, 0.01, {
                onComplete: function() {
                    self.$.twoLines.style.display = 'block';
                    self.topText = 'PROVIDED BY ' + prize.provided;
                }
            });

            this.tl.call(function() {
                if (prize.grand) {
                    self.bottomText = 'Grand Prize: ' + prize.name + ' (Minimum Bid: ' + prize.minimumbid + ')';
                } else {
                    self.bottomText = prize.name + ' (Minimum Bid: ' + prize.minimumbid + ')';
                }
            }, null, null, '+=0.08');

            // Give the prize some time to show
            this.tl.to({}, this.displayDuration, {});

            // If we're just showing this one prize on-demand, show "Up Next" next.
            if (immediate) this.tl.call(this.showNext, null, this, '+=0.01');
        },

        showNext: function (immediate) {
            if (window.nextRun) {
                var self = this;
                if (immediate) this.tl.clear();
                this.tl.call(this._showLabel, ['UP NEXT', '31px'], this);

                // GSAP is dumb with `call` sometimes. Putting this in a near-zero duration tween seems to be more reliable.
                this.tl.to({}, 0.01, {
                    onComplete: function() {
                        self.$.twoLines.style.display = 'block';

                        /* Depending on how we enter the very end of the schedule, we might end up in this func
                         * after window.nextRun has been set to null. In that case, we immediately clear the
                         * timeline and bail out to showing bids again.
                         */
                        if (window.nextRun) {
                            self.topText = window.nextRun.runners.join(', ');
                        } else {
                            self.tl.clear();
                            self.tl.call(self.showBids, null, self);
                        }
                    }
                });

                this.tl.call(function() {
                    self.bottomText = window.nextRun.game + ' - ' + window.nextRun.category;
                }, null, null, '+=0.08');

                // Give it some time to show
                this.tl.to({}, this.displayDuration, {});

                this.tl.call(this.showCTA, null, this, '+=0.01');
            }
        },

        showCTA: function(immediate) {
            var self = this;
            if (immediate) this.tl.clear();
            this.tl.add('showCTA_start');
            this.tl.add(this._hideLabel(), 'showCTA_start');

            // This is all very silly and I am sorry.
            this.tl.to({}, 0.01, {
                onStart: function () {
                    self.$.fullLine.style.display = 'block';

                    // Create a "wrapper" div. This is what will actually get put in our qPlate.
                    var wrapper = document.createElement('div');
                    wrapper.classList.add('flexCenter');

                    // Make the content that will go inside the wrapper.
                    var span = document.createElement('span');
                    var div = document.createElement('div');
                    span.innerHTML = '<b>Summer Games Done Quick</b> benefits';
                    div.id = 'msf';
                    wrapper.appendChild(span);
                    wrapper.appendChild(div);

                    // Put it in the qPlate hopper.
                    self.$.fullLine.fillHopper(wrapper);
                }
            }, 'showCTA_start+=' + (self.$.bottomLine.duration / 2 + 0.01));

            this.tl.call(function() {
                var b = document.createElement('b');
                b.textContent = 'Donate at gamesdonequick.com';

                // Put it in the qPlate hopper.
                self.$.fullLine.fillHopper(b);
            }, null, null, '+=' + this.displayDuration);

            // Give it some time to show
            this.tl.to({}, this.displayDuration, {});

            // Hide, then show bids
            this.tl.to({}, this.$.fullLine.duration / 2, {
                onStart: function() {
                    self.$.fullLine.fillHopperText('');
                },
                onComplete: function() {
                    self.$.fullLine.style.display = 'none';
                    self.showBids();
                }
            })
        },

        _showLabel: function (text, size) {
            var self = this;
            var tmpTL = new TimelineLite();

            // TODO: Silly, hacky code. This shouldn't be part of this func, and this should be done in a better fashion.
            if (this.$.fullLine.$.display.innerHTML !== '') {
                tmpTL.to(this.$.fullLine, this.$.fullLine.duration / 2 + 0.01, {
                    onStart: function () {
                        self.$.fullLine.fillHopperText('');
                    },
                    onComplete: function () {
                        self.$.twoLines.style.display = 'block';
                        self.$.fullLine.style.display = 'none';
                    }
                })
            }

            if (this.labelShowing) {
                tmpTL.to(this.$.label, 0.25, {
                    opacity: 0,
                    ease: Linear.easeNone,
                    onComplete: function () {
                        self.$.label.innerHTML = text;
                        self.$.label.style.fontSize = size;
                    }
                });
                tmpTL.to(this.$.label, 0.25, {
                    opacity: 1,
                    ease: Linear.easeNone
                });
            } else {
                tmpTL.to(this.$.labelContainer, 0.5, {
                    onStart: function () {
                        self.labelShowing = true;
                        self.$.labelContainer.style.display = 'flex';
                        self.$.label.innerHTML = text;
                        self.$.label.style.fontSize = size;
                    },
                    x: '0%',
                    ease: Power3.easeOut
                });
            }
            return tmpTL;
        },

        _hideLabel: function () {
            var self = this;
            return TweenLite.to(this.$.labelContainer, this.$.topLine.duration / 2 + 0.01, {
                onStart: function () {
                    self.labelShowing = false;
                    self.topText = '';
                    self.bottomText = '';
                },
                x: '-100%',
                ease: Power3.easeIn,
                onComplete: function() {
                    self.$.labelContainer.style.display = 'none';
                    self.$.twoLines.style.display = 'none';
                }
            });
        }
    });
</script>
